# Issues

## Convention

✅: 해결이 완료된 이슈<br/>
❌: 미해결 상태로 잠시 보류 중인 이슈<br/>
⭐️: 현재 진행중인 이슈

---

[README.md로 돌아가기](../README.md)

## 목차

- [✅ 001: 탭 페이지 간 로그인 상태 공유](#✅-issue-001-탭-페이지-간에-로그인-상태를-어떻게-공유할-수-있을까)
- [❌ 002: 서버에서 session 관리](#❌-issue-002-서버에서-session-데이터를-어떻게-관리할-수-있을까)
- [⭐️ 003: 컴포넌트에서 데이터 로직 분리하기](#⭐️-issue-003-컴포넌트에서-데이터-로직을-분리해서-설계하기)

---

## ✅ Issue 001: 탭 페이지 간에 로그인 상태를 어떻게 공유할 수 있을까?

1. 네이버는 어떻게 로그인 이후 탭 간에 로그인 상태를 연결할 수 있을까 하는 생각이 들었다. 게다가 브라우저가 종료되지 않더라도 naver 페이지(들)만 꺼지면 자동으로 로그아웃이 되는 것이었다.

2. 일단 떠오르는 건 `cookie, local storage, session storage`를 사용하면 될 것 같다. 그런데 _session storage_ 는 페이지 세션에 한정되므로 탭 간에 상태를 공유하는 것은 불가능하므로 배제되었다.<br/>
   그럼 _cookie_ 나 _local storage_ 를 사용할 수 있을 것 같다.
   local storage는 영구적으로 유지되므로, 수명을 정할 수 있는 cookie에 비해 보안성에서 보다 취약할 것이라고 예상되서 탈락이다.
   **따라서 cookie를 사용해야 할 것 같다.** 하지만 세션 쿠키는 브라우저가 종료되어야만 사라지는데 어떻게 탭이 사라진 것만으로 구현하지...

3. 알고보니 (1)의 전제가 잘못되었다. _"~~게다가 브라우저가 종료되지 않더라도 naver 페이지(들)만 꺼지면 자동으로 로그아웃이 되는 것이었다.~~"_ 는 내가 왜인지 몰라도 잘못 알고 있었던 것이었다. 네이버도 동일하게 브라우저가 종료시에 session cookie가 만료되면서 로그아웃된다.

## ❌ Issue 002: 서버에서 session 데이터를 어떻게 관리할 수 있을까?

1. 세션 쿠키를 연구하는 과정에서 궁금증이 생겼다. 클라이언트 쪽에서는 (단순히 세션 id를 담은 쿠키가 아니라)세션 쿠키가 브라우저의 종료와 함께 삭제되지만 서버측에서는 어떻게 세션 데이터를 삭제할 수 있을까?

2. 일단은 `max-age`를 설정하여서 서버측에서도 세션이 일정 시간이 지나면 만료된 세션 데이터임을 알 수 있도록 해보았다. 그리고 `session-file-store`에 `rolling` 옵션을 적용해서 서버와 통신이 있을 시에 _max-age_ 를 갱신하는 식으로 설정해 두었다. 그런데 _max-age_ 를 설정하면 클라이언트 측에서 세션 쿠키로 인식하지 못했다. _max-age_ 를 가지면 영구적 쿠키가 되어서 브라우저에서 쿠키를 삭제하지 않았다.

3. 아무래도 `session-file-storage`를 사용하는 한계인 것 같다. 실제로는 `Redis`와 같은 _database_ 를 따로 설정한다고 하는데 아무래도 _database_ 측에서 따로 설정을 통해서 세션을 독립적으로 삭제하는 것 같다. oracle의 문서를 보는데 아무래도 db의 자체적인 로직으로 삭제 작업을 수행하는 것처럼 보인다.

## ⭐️ Issue 003: 컴포넌트에서 데이터 로직을 분리해서 설계하기

1. 사실 이게 예전에 `react`에서 사용되던 presenter/container 방식인 것을 알고는 있다. 그러나 컴포넌트가 재사용 가능하다는 점을 생각했을 때, 컴포넌트에서 데이터를 관리하는 로직을 분리시켜야 한다는 생각이 들었다. 이 프로젝트의 경우 최종적으로 _page_ 가 최상위 _container_ 이므로 모든 데이터에 관한 로직을 _page_ 내부에서 관리하는 식으로 진행하고 싶었다.
2. 아니면 차라리 `atomic design`으로 진행을 했어야 했나하는 생각도 든다. 예전에 언뜻 지나가며 공부하기로는 component가 순수하길 바라는 지금의 의도가 _atomic design_ 과 더 어울릴 것 같다는 생각이 든다.
3. 일단은 어렵게 접근하지 말고 차근차근 풀어나가도록 한다. 첫 번째로 state는 _water fall_ 방식으로 다루기로 한 상태에서 여러 가지 방법을 시도해 보기로 했다.
   1. `recoil`과 같이 작은 단위의 데이터를 관리하는 _useState_ 를 여러개 선언해서 관리해보았다. 이 경우 너무 많은 선언이 생기면서 오히려 전체적으로 복잡해졌다.
   2. _useReducer_ 을 사용해보았다. `form`에서 다루는 모든 데이터를 _useReducer_ 로 다루기로 하고 1과는 반대로 모든 데이터를 그 아래에 쑤셔넣었다. 한 곳에서 데이터를 관리하니 마음은 편했지만, 관리나 활용에 어려움이 생길 것 같았다.
   3. state를 _rendering_ 과 _fetch_ 라는 목적에 따라 구분하기로 했다. 일단은 이걸로 만족스럽다. _useState_ 를 사용했는데 굳이 _useReducer_ 를 사용할 정도의 복잡한 로직이 필요 없었기 때문이다.
