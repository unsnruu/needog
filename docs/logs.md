# Logs

[README.md로 돌아가기](../README.md)

## 목차

- [Update](#updates)

  - [Update 1.0.1](#update-101220421)
  - [Update 1.0.0](#update-100220322)

</br>

- [TILs](#t)
  - [22.04.22](#220422) chro

---

## Updates

### Update 1.0.1(22/04/21)

- `components/Form/*`에 대해서 파일 구조 설계. 리팩토링 진행
- recoil 파일 구조를 설계

### Update 1.0.0(22.03.22)

- 프로젝트 개발 시작
- 아주 기본적인 기능을 위한 서버와 클라이언트 구현
- 큰 틀에서의 프로젝트 기능 구현하기

---

## TILs

### 22.04.23

#### pages/Missing/Write.tsx

- `text` state에 대해서는 throttle을 구현하기
  - 왜 debounce가 아니냐면, 만약 자동저장 시스템을 구현한다고 가정해보자. 입력 중간에 끊김이 발생했을 때 debounce는 사용자가 시작부터 계속 입력중이었다면
    아예 저장이 안될 확률이 있기 때문이다.
  - 근데 throttle을 적용하고 나서 만약에 사용자가 submit을 해버리면 어쩌지.
  - throttle을 onChange에서 도입하는 게 아니라 페이지를 기준으로 자동 업데이트를 구현하는 쪽으로 해야겠다.
- page routing을 client-side에서 관리하는 경우 server측과의 통신에서 `Method`를 `POST`로 설정하는 것이 낫지 않을까 싶다
  - 왜냐하면 `GET`을 사용하면 혹시라도 주소창을 이용해서 만들어 놓은 페이지가 아니라 데이터를 관리하는 서버의 url로 접속할 수 있기 때문이다.
  - 더 나은 방법을 생각해보자면, (1) 클라인언트를 제공하는 서버와 데이터를 관리하는 서버를 아예 분리하기, (2) 서버측과 통신 가능한 라우터를 아예 난수처리 해서 거의 접근 가능성을 차단하기 정보가 방법이 아닐까 싶다.

### 22.04.22

- Form을 만드는 것 자체가 오히려 확장성과 유연함이 떨어진다고 생각해서 사용하지 않기로 했다. Form을 컴포넌트 형태로 구현한다는 자체가 지금으로서는 오히려 비효율적으로 작용하는 것 같다.
- Form 없이도 Write에서 구현을 해보았는데도 꽤나 깔끔한 형태로 컴포넌트가 나왔다. 데이터를 다루는 방식도 더 편리하다.
- 다만 Form을 재사용 가능한 컴포넌트로 제작하는 노력에서 `custom hook`인 `useRegion`을 만들어서 편리하게 사용할 수 있었다.
- Type을 정의하는 과정에서도 전체적인 구조에 대해 생각할 수 있던 기회였다.
